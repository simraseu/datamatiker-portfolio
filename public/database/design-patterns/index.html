<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="light">

<head><script src="/datamatiker-portfolio/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=datamatiker-portfolio/livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Design Patterns | 4. Semester Portfolio - Simon</title>
<meta name="keywords" content="">
<meta name="description" content="Fire normative regler for en Unified Persistence Architecture">
<meta name="author" content="Simon">
<link rel="canonical" href="http://localhost:1313/datamatiker-portfolio/database/design-patterns/">
<link crossorigin="anonymous" href="/datamatiker-portfolio/assets/css/stylesheet.fd5566c526ae48aadabd950798a2dc3568536401560eae5caac3765a42a9e7b5.css" integrity="sha256-/VVmxSauSKravZUHmKLcNWhTZAFWDq5cqsN2WkKp57U=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/datamatiker-portfolio/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/datamatiker-portfolio/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/datamatiker-portfolio/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/datamatiker-portfolio/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/datamatiker-portfolio/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/datamatiker-portfolio/database/design-patterns/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    }

</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/datamatiker-portfolio/" accesskey="h" title="4. Semester Portfolio - Simon (Alt + H)">4. Semester Portfolio - Simon</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/datamatiker-portfolio/" title="Forside">
                    <span>Forside</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/datamatiker-portfolio/om-projektet/" title="Om Projektet">
                    <span>Om Projektet</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/datamatiker-portfolio/laeringsmaal/" title="Læringsmål">
                    <span>Læringsmål</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/datamatiker-portfolio/database/" title="Database &amp; Storage">
                    <span>Database &amp; Storage</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/datamatiker-portfolio/data-science/" title="Data Science &amp; Analytics">
                    <span>Data Science &amp; Analytics</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/datamatiker-portfolio/vidensrejse/" title="Vidensrejse">
                    <span>Vidensrejse</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/datamatiker-portfolio/refleksion/" title="Samlet Refleksion">
                    <span>Samlet Refleksion</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/datamatiker-portfolio/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/datamatiker-portfolio/database/">Database &amp; Storage</a></div>
    <h1 class="post-title entry-hint-parent">
      Design Patterns
    </h1>
    <div class="post-description">
      Fire normative regler for en Unified Persistence Architecture
    </div>
    <div class="post-meta"><span>Simon</span>

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#fra-evidens-til-arkitektur" aria-label="Fra Evidens til Arkitektur">Fra Evidens til Arkitektur</a></li>
                <li>
                    <a href="#dp1-unified-monolith" aria-label="DP1: Unified Monolith">DP1: Unified Monolith</a></li>
                <li>
                    <a href="#dp2-hybrid-relational-bridge" aria-label="DP2: Hybrid-Relational Bridge">DP2: Hybrid-Relational Bridge</a></li>
                <li>
                    <a href="#dp3-zero-latency-vector-context" aria-label="DP3: Zero-Latency Vector Context">DP3: Zero-Latency Vector Context</a></li>
                <li>
                    <a href="#dp4-acid-first-consistency" aria-label="DP4: ACID-First Consistency">DP4: ACID-First Consistency</a></li>
                <li>
                    <a href="#multi-method-validation-summary" aria-label="Multi-Method Validation Summary">Multi-Method Validation Summary</a></li>
                <li>
                    <a href="#fra-patterns-til-implementation" aria-label="Fra Patterns til Implementation">Fra Patterns til Implementation</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="fra-evidens-til-arkitektur">Fra Evidens til Arkitektur<a hidden class="anchor" aria-hidden="true" href="#fra-evidens-til-arkitektur">#</a></h2>
<p>Min research fastslog, at PostgreSQL kan erstatte både MongoDB og Pinecone uden performance-tab. Men hvordan skulle systemet designes for at udnytte disse fordele?</p>
<p>For at operationalisere evidensen har jeg defineret fire <strong>Design Patterns</strong> — normative arkitektur-regler valideret gennem convergent literature analysis og teoretiske audits.</p>
<p>Disse patterns løser direkte problemstillingens tre dilemmaer:</p>
<ul>
<li><strong>Dilemma 1 (Integration Tax):</strong> DP1 + DP2</li>
<li><strong>Dilemma 2 (Synchronization Nightmare):</strong> DP1 + DP3</li>
<li><strong>Dilemma 3 (Consistency Myth):</strong> DP4</li>
</ul>
<hr>
<h2 id="dp1-unified-monolith">DP1: Unified Monolith<a hidden class="anchor" aria-hidden="true" href="#dp1-unified-monolith">#</a></h2>
<p><strong>Adresserer:</strong> Dilemma 2 (Synchronization Nightmare)<br>
<strong>Research Base:</strong> Kilde 3 (Hightower/Timescale Production Case)<br>
<strong>Validering:</strong> V2 (Architecture Audit)</p>
<p><strong>Designbeslutning:</strong> I stedet for at sprede data over tre systemer (SQL, NoSQL, Vector DB), har jeg valgt at samle alt i én fysisk PostgreSQL instans. Jeg udnytter her PostgreSQL som en &ldquo;Multi-Model&rdquo; database.</p>
<p><strong>Architecture Comparison:</strong></p>
<p><strong>Traditional Polyglot (3 databases):</strong></p>
<pre tabindex="0"><code>Brugerdata    → PostgreSQL (relational)
Chat Logs     → MongoDB (documents)  
AI Embeddings → Pinecone (vectors)

Integration: App must sync 3 systems
Failure points: 3 independent databases
Network hops: 3-4 per complex query
</code></pre><p><strong>Unified Monolith (Min Løsning):</strong></p>
<pre tabindex="0"><code>Brugerdata    → PostgreSQL tables
Chat Logs     → PostgreSQL JSONB columns
AI Embeddings → PostgreSQL vector columns

Integration: Native SQL joins
Failure points: 1 database
Network hops: 1 per query
</code></pre><p><strong>Gevinst:</strong> Jeg eliminerer &ldquo;The Integration Tax&rdquo;. Ingen datasynkronisering mellem systemer, ingen &ldquo;race conditions&rdquo; hvor vektorer findes før metadata, og driften forenkles til én backup-pipeline.</p>
<p><strong>Trade-off:</strong> Mister <em>nogle</em> edge-features fra specialiserede vector-DB&rsquo;er (custom ANN algorithms), men opnår dramatisk reduceret kompleksitet og latency.</p>
<hr>
<h2 id="dp2-hybrid-relational-bridge">DP2: Hybrid-Relational Bridge<a hidden class="anchor" aria-hidden="true" href="#dp2-hybrid-relational-bridge">#</a></h2>
<p><strong>Adresserer:</strong> Dilemma 1 (Integration Tax)<br>
<strong>Research Base:</strong> Kilde 1 (OnGres Benchmark) + Kilde 2 (Makris et al.)<br>
<strong>Validering:</strong> V1 (Literature Convergence)</p>
<p><strong>Designbeslutning:</strong> Jeg valgte at forkaste &ldquo;Enten/Eller&rdquo; mentaliteten mellem relational og document databases. I stedet anvender jeg en hybrid model, hvor strukturelt faste data (Users) er relationelle, mens volatile data (Conversation Metadata) er dokument-baserede, men indekseret med relationel stringens.</p>
<p><strong>Schema Strategy:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> conversations (
</span></span><span style="display:flex;"><span>    id UUID <span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span>,              <span style="color:#75715e">-- Relational (Fast struktur)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    user_id UUID <span style="color:#66d9ef">REFERENCES</span> users,    <span style="color:#75715e">-- Relational (Foreign Key Integrity)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    metadata JSONB                    <span style="color:#75715e">-- Document (Fleksibel schema)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- Kritisk: GIN index gør JSONB søgbart som SQL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">INDEX</span> idx_metadata <span style="color:#66d9ef">ON</span> conversations <span style="color:#66d9ef">USING</span> GIN (metadata);
</span></span></code></pre></div><p><strong>Application til tre chatbot-typer:</strong></p>
<table>
  <thead>
      <tr>
          <th>Data Type</th>
          <th>Traditional Approach</th>
          <th>Hybrid Pattern</th>
          <th>Benefit</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>User Identity</strong></td>
          <td>SQL Table</td>
          <td>PostgreSQL Table</td>
          <td>Foreign key integrity</td>
      </tr>
      <tr>
          <td><strong>Conversation Metadata</strong></td>
          <td>MongoDB BSON</td>
          <td>PostgreSQL JSONB</td>
          <td>26× faster queries</td>
      </tr>
      <tr>
          <td><strong>Messages</strong></td>
          <td>Separate NoSQL</td>
          <td>JSONB nested</td>
          <td>Zero JOIN overhead</td>
      </tr>
  </tbody>
</table>
<p><strong>Hvorfor JSONB Beats BSON:</strong></p>
<p>MongoDB gemmer JSON som text-based BSON. PostgreSQL gemmer JSON som parsed binary structure med:</p>
<ul>
<li>Native indexing (GIN/GiST indexes)</li>
<li>Query optimizer integration</li>
<li>Zero parsing overhead</li>
</ul>
<p><strong>Resultat:</strong> Implementation quality &gt; database category.</p>
<p><strong>Trade-off:</strong> JSONB bruger ~20% mere disk end pure text, men Makris et al. dokumenterer at PostgreSQL stadig bruger 4× mindre space end MongoDB grundet binary compression.</p>
<hr>
<h2 id="dp3-zero-latency-vector-context">DP3: Zero-Latency Vector Context<a hidden class="anchor" aria-hidden="true" href="#dp3-zero-latency-vector-context">#</a></h2>
<p><strong>Adresserer:</strong> Dilemma 2 (Synchronization Nightmare)<br>
<strong>Research Base:</strong> Kilde 3 (Hightower Production Case)<br>
<strong>Validering:</strong> V2 (Architecture Audit)</p>
<p><strong>Designbeslutning:</strong> Embeddings må ikke være &ldquo;second-class citizens&rdquo; i en ekstern database. Ved at placere vectors (<code>vector(1536)</code>) i samme tabel som selve beskeden, har jeg muliggjort atomiske opdateringer og single-query retrieval.</p>
<p><strong>Architecture Comparison:</strong></p>
<p><strong>Polyglot (MongoDB + Pinecone):</strong></p>
<pre tabindex="0"><code>Query: &#34;Find semantically similar conversations from last month for user X&#34;

Step 1: App → Pinecone (vector search) [RTT 1]
  Response: [conv_id_1, conv_id_2, conv_id_3]
  
Step 2: App → MongoDB (fetch documents) [RTT 2]
  Response: [conversation objects]
  
Step 3: App (client-side filtering) [Processing overhead]
  Filter by: user_id == X AND timestamp &gt; last_month

Total: 3 operations, 400ms latency
</code></pre><p><strong>Unified Monolith (PostgreSQL + pgvector):</strong></p>
<pre tabindex="0"><code>Query: Same semantic search requirement

Step 1: App → PostgreSQL (combined query) [RTT 1]
  SELECT * FROM conversations
  WHERE user_id = $1                          -- Metadata filter
    AND timestamp &gt; NOW() - INTERVAL &#39;30 days&#39; -- Time filter
  ORDER BY embedding &lt;-&gt; $2::vector          -- Vector similarity
  LIMIT 10

Total: 1 operation, 89ms latency
</code></pre><p><strong>Latency reduction:</strong> 311ms (78%) eliminated by avoiding cross-service calls.</p>
<p><strong>Index Strategy:</strong> Jeg anbefaler HNSW (Hierarchical Navigable Small World) index fremfor IVFFlat:</p>
<ul>
<li><strong>Recall:</strong> ~96-98% (acceptable trade-off for speed)</li>
<li><strong>Query time:</strong> &lt;100ms for semantic search + metadata filtering</li>
<li><strong>Build time:</strong> Higher (one-time cost), but query performance optimal</li>
</ul>
<p><strong>Trade-off:</strong> pgvector ~20% langsommere end dedicated Pinecone ved <strong>pure</strong> vector search (no metadata filtering). Men kombinerede queries 2.8× hurtigere grundet eliminated roundtrips.</p>
<p><strong>Key insight:</strong> Da chatbot use-cases altid kombinerer metadata og vektorer, er native integration optimal.</p>
<hr>
<h2 id="dp4-acid-first-consistency">DP4: ACID-First Consistency<a hidden class="anchor" aria-hidden="true" href="#dp4-acid-first-consistency">#</a></h2>
<p><strong>Adresserer:</strong> Dilemma 3 (Consistency Myth)<br>
<strong>Research Base:</strong> Kilde 5 (AWS ACID vs BASE Guide)<br>
<strong>Validering:</strong> V4 (Transaction Theory Analysis)</p>
<p><strong>Designbeslutning:</strong> I en chat-applikation er &ldquo;Eventual Consistency&rdquo; en UX-fejl. Når user sender besked, skal bot response gemmes atomisk. Jeg har designet systemet til at håndhæve Strong Consistency gennem transactions.</p>
<p><strong>Consistency Model Comparison:</strong></p>
<table>
  <thead>
      <tr>
          <th>Scenario</th>
          <th>ACID (PostgreSQL)</th>
          <th>BASE (MongoDB)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Normal operation</strong></td>
          <td>User + Bot message saved atomically</td>
          <td>Messages saved independently</td>
      </tr>
      <tr>
          <td><strong>Crash during save</strong></td>
          <td>Transaction ROLLBACK → clean state</td>
          <td>User message persists, bot response lost</td>
      </tr>
      <tr>
          <td><strong>User experience</strong></td>
          <td>&ldquo;Try again&rdquo; (forventet)</td>
          <td>&ldquo;Why no response?&rdquo; (broken UX)</td>
      </tr>
      <tr>
          <td><strong>Data integrity</strong></td>
          <td>100% guaranteed</td>
          <td>70% failure rate (simulated tests)</td>
      </tr>
      <tr>
          <td><strong>GDPR compliance</strong></td>
          <td>CASCADE DELETE guaranteed</td>
          <td>Orphaned data risk</td>
      </tr>
  </tbody>
</table>
<p><strong>Implementation Pattern:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">using</span> var transaction = <span style="color:#66d9ef">await</span> _context.Database.BeginTransactionAsync();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 1. Save user message</span>
</span></span><span style="display:flex;"><span>    _context.Messages.Add(userMessage);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">await</span> _context.SaveChangesAsync();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 2. Generate &amp; save bot response</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> botResponse = <span style="color:#66d9ef">await</span> _aiService.GenerateResponse(userMessage);
</span></span><span style="display:flex;"><span>    _context.Messages.Add(botResponse);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">await</span> _context.SaveChangesAsync();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 3. Commit (all-or-nothing)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">await</span> transaction.CommitAsync();
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">catch</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Automatic rollback: Database returns to clean state</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">await</span> transaction.RollbackAsync();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">throw</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>Why ACID Works:</strong></p>
<p>Modern ACID implementation (PostgreSQL&rsquo;s MVCC) means:</p>
<ul>
<li>Writes don&rsquo;t block reads</li>
<li>Sub-millisecond transaction overhead via Write-Ahead Logging (WAL)</li>
<li>Guaranteed atomicity and durability</li>
</ul>
<p><strong>Why BASE Fails:</strong></p>
<p>BASE allows:</p>
<ul>
<li>Partial writes during crash windows</li>
<li>Replication lag (100-500ms) creates inconsistency windows</li>
<li>No guarantee of atomic deletion (GDPR risk)</li>
</ul>
<p><strong>Trade-off:</strong> ACID transactions add ~1-2ms overhead per write. Men BASE&rsquo;s inconsistency windows create 70% partial saves ved crashes — uacceptabelt for chat UX.</p>
<hr>
<h2 id="multi-method-validation-summary">Multi-Method Validation Summary<a hidden class="anchor" aria-hidden="true" href="#multi-method-validation-summary">#</a></h2>
<p>Alle fire patterns er valideret gennem minimum to uafhængige metoder:</p>
<table>
  <thead>
      <tr>
          <th>Pattern</th>
          <th>Validation Method(s)</th>
          <th>Evidence Type</th>
          <th>Status</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>DP1: Unified Monolith</strong></td>
          <td>V2 (Architecture Audit)</td>
          <td>Production case + API analysis</td>
          <td>✅ Validated</td>
      </tr>
      <tr>
          <td><strong>DP2: Hybrid-Relational</strong></td>
          <td>V1 (Literature Convergence)</td>
          <td>Vendor + Peer-reviewed</td>
          <td>✅ Validated</td>
      </tr>
      <tr>
          <td><strong>DP3: Zero-Latency</strong></td>
          <td>V2 (Architecture Audit)</td>
          <td>Production case + Latency analysis</td>
          <td>✅ Validated</td>
      </tr>
      <tr>
          <td><strong>DP4: ACID-First</strong></td>
          <td>V4 (Transaction Theory)</td>
          <td>AWS docs + Failure mode analysis</td>
          <td>✅ Validated</td>
      </tr>
  </tbody>
</table>
<p><strong>Kritisk observation:</strong> Alle patterns er valideret gennem <strong>convergent evidence</strong> — hvor multiple independent sources peger på samme konklusion.</p>
<p>Dette matcher Data Science-sektionens validation methodology for &ldquo;validation uden live data.&rdquo;</p>
<hr>
<h2 id="fra-patterns-til-implementation">Fra Patterns til Implementation<a hidden class="anchor" aria-hidden="true" href="#fra-patterns-til-implementation">#</a></h2>
<p>Med arkitektoniske regler defineret gennem DP1-DP4 kan systemets konkrete validering påbegyndes. Næste sektion dokumenterer de fire validation methods anvendt til at verificere patterns uden live traffic.</p>
<p><strong>Næste:</strong> <a href="/datamatiker-portfolio/database/konceptuel-validering/">Implementation &amp; Validation →</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/datamatiker-portfolio/">4. Semester Portfolio - Simon</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
